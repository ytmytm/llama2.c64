- Makefile jest oryginalny (niemal)
- programy testowe budowane skryptami oscar* i uruchamiają x64 z obrazem REU weights.bin
- obraz REU z stories260K.bin za pomocą strip-config.sh; usunięty obiekt config (bo inne typy danych) i padding do równych 2MB (niezbędny dla VICE)
- config.bin to początek ze stories260K zapisany w typy danych Config64
    - zapisany za pomocą transformer.c - konwersja w int16_t
- config.bin wciągany binarnie w transformer64.c
- tokenizer2.bin zapisany z run.c
- tokenizer2.bin wciągany binarnie w tokenizer64.c

- token 0x0a to \n

nnet64.c
+ rope() może policzyć fcr/fci raz i buforować (tylko [head_size] różnych wartości: połowa to sin(), połowa to cos(), indeksowane co 2)
- wspólne offsety można wydzielić (są takie same dla key_cache i value_cache?)
- buforowanie danych z REU (cały wiersz/kolumna)
+ potrzebuje przypadku testowego native (tak samo pierwsze 1-2 mnożenia)
+ nnet64 rmsnorm()
+ nnet64 softmax()
+ nnet64 rope()
    - slightly different results (b/c of numerical differences?) may affect further calculations
+ nnet64 attn()
    + blokuje się wewnątrz, też wydzielić do funkcji
    + test values
+ nnet64 forward() (i jego test) potrzebuje przerobienia na arytmetykę pointerów w REU
    - jeśli dodam matmul_local (wynik w local) to s->q też przywrócić do local (+uaktualnić test)
    - s->q przywrócić do local (użyć matmul_local)
    - wszędzie w licznikach gdzie było int daję uint16_t (dobrze?)
    - przy offsetach do REUPtr trzeba było dodać (uint32_t) do drugiego składnika
+ nnet64 matmul() potrzebuje przerobienia na pointery REU
    - i trzymać jeden pointer na xout, nie trzeba obliczać pozycji za każdym razem bo i tak zmienia się o 1
    - do/z REU można przepisywać całe policzone wiersze/kolumny (po 64 bajty)
+ ?rozne miejsca na wyniki s->q, s->k, s->v (lokalne i REU) - zrobić 2 funkcje na matmul()?
    + albo s->q przenieść do reu (przeniesione)
- ?może ten offset na wagi przekazywać jako następny parametr (inaczej u źródła trzeba zawsze mnożyć przez sizeof(float)) 
    - zobaczyć ile razy to jest użyte, może nie trzeba
    - uwaga na atrytmetykę wskaźników gdy reu

sampler64.c
+ przetestowany
+ softmax przetestowany
- nie obsługuje top-p sampling

generate64.c
~ testowany 40s/token (warp) ~ 8min (realtime)
- test token sequence and sampler result (need to disable other status/debug messages)

test-nnet.c
- ma szybszy matmul2 (operacje tylko na wskaźnikach)

[REUPtr as float*] - doesn't work as pointers are 16-bit in Oscar64 (branch backtofloat)