- Makefile jest oryginalny (niemal)
- programy testowe budowane skryptami oscar* i uruchamiają x64 z obrazem REU weights.bin
- obraz REU z stories260K.bin za pomocą strip-config.sh; usunięty obiekt config (bo inne typy danych) i padding do równych 2MB (niezbędny dla VICE)
- config.bin to początek ze stories260K zapisany w typy danych Config64
    - zapisany za pomocą transformer.c - konwersja w int16_t
- config.bin wciągany binarnie w transformer64.c
- tokenizer2.bin zapisany z run.c
- tokenizer2.bin wciągany binarnie w tokenizer64.c

nnet64.c
+ potrzebuje przypadku testowego native (tak samo pierwsze 1-2 mnożenia)
+ nnet64 rmsnorm()
+ nnet64 softmax()
- nnet64 forward() (i jego test) potrzebuje przerobienia na arytmetykę pointerów w REU
    - jeśli dodam matmul_local (wynik w local) to s->q też przywrócić do local (+uaktualnić test)
+ nnet64 matmul() potrzebuje przerobienia na pointery REU
    - i trzymać jeden pointer na xout, nie trzeba obliczać pozycji za każdym razem bo i tak zmienia się o 1
    - do/z REU można przepisywać całe policzone wiersze/kolumny (po 64 bajty)
+ ?rozne miejsca na wyniki s->q, s->k, s->v (lokalne i REU) - zrobić 2 funkcje na matmul()?
    + albo s->q przenieść do reu (przeniesione)
- ?może ten offset na wagi przekazywać jako następny parametr (inaczej u źródła trzeba zawsze mnożyć przez sizeof(float)) 
    - zobaczyć ile razy to jest użyte, może nie trzeba
    - uwaga na atrytmetykę wskaźników gdy reu

sampler.c
- używa softmax() - uwaga na źródło danych (remote + ptr offset *sizeof(float))

test-nnet.c
- ma szybszy matmul2 (operacje tylko na wskaźnikach)

[REUPtr as float*] - doesn't work as pointers are 16-bit in Oscar64 (branch backtofloat)